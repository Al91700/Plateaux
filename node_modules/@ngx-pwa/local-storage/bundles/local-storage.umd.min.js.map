{"version":3,"file":"local-storage.umd.min.js","sources":["../../out-tsc/lib/src/service/databases/local-database.ts","../../out-tsc/lib/src/service/databases/indexeddb-database.ts","../../out-tsc/lib/src/service/databases/localstorage-database.ts","../../out-tsc/lib/src/service/databases/mock-local-database.ts","../../out-tsc/lib/src/service/validation/json-validator.ts","../../out-tsc/lib/src/service/lib.service.ts"],"sourcesContent":["import { Injectable, PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Observable } from 'rxjs';\n\nimport { IndexedDBDatabase } from './indexeddb-database';\nimport { LocalStorageDatabase } from './localstorage-database';\nimport { MockLocalDatabase } from './mock-local-database';\n\nexport function localDatabaseFactory(platformId: Object) {\n\n  if (isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {\n\n    /* Try with IndexedDB in modern browsers */\n    return new IndexedDBDatabase();\n\n  } else if (isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {\n\n    /* Try with localStorage in old browsers (IE9) */\n    return new LocalStorageDatabase();\n\n  } else {\n\n    /* Fake database for server-side rendering (Universal) */\n    return new MockLocalDatabase();\n\n  }\n\n};\n\n@Injectable({\n  providedIn: 'root',\n  useFactory: localDatabaseFactory,\n  deps: [PLATFORM_ID]\n})\nexport abstract class LocalDatabase {\n\n  abstract getItem<T = any>(key: string): Observable<T | null>;\n  abstract setItem(key: string, data: any): Observable<boolean>;\n  abstract removeItem(key: string): Observable<boolean>;\n  abstract clear(): Observable<boolean>;\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, ReplaySubject, fromEvent as fromEvent, of as of, throwError, race } from 'rxjs';\nimport { map, mergeMap, first } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IndexedDBDatabase implements LocalDatabase {\n\n  /**\n   * IndexedDB database name for local storage\n   */\n  protected readonly dbName = 'ngStorage';\n  /**\n   * IndexedDB object store name for local storage\n   */\n  protected readonly objectStoreName = 'localStorage';\n  /**\n   * IndexedDB key path name for local storage (where an item's key will be stored)\n   */\n  protected readonly keyPath = 'key';\n  /**\n   * IndexedDB data path name for local storage (where items' value will be stored)\n   */\n  protected readonly dataPath = 'value';\n  /**\n   * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection\n   * even after the connection success event happened\n   */\n  protected database: ReplaySubject<IDBDatabase>;\n\n  /**\n   * Connects to IndexedDB\n   */\n  constructor() {\n\n    /* Creating the RxJS ReplaySubject */\n    this.database = new ReplaySubject<IDBDatabase>();\n\n    /* Connecting to IndexedDB */\n    this.connect();\n\n  }\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string) {\n\n    /* Opening a trasaction and requesting the item in local storage */\n    return this.transaction().pipe(\n      map((transaction) => transaction.get(key)),\n      mergeMap((request) => {\n\n        /* Listening to the success event, and passing the item value if found, null otherwise */\n        const success = (fromEvent(request, 'success') as Observable<Event>).pipe(\n          map((event) => (event.target as IDBRequest).result),\n          map((result) => result && (this.dataPath in result) ? (result[this.dataPath] as T) : null)\n        );\n\n        /* Merging success and errors events and autoclosing the observable */\n        return (race(success, this.toErrorObservable(request, `getter`)) as Observable<T | null>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    /* Storing null is not correctly supported by IndexedDB and unnecessary here */\n    if (data == null) {\n\n      return of(true);\n\n    }\n\n    /* Opening a transaction and checking if the item already exists in local storage */\n    return this.getItem(key).pipe(\n      map((existingData) => (existingData == null) ? 'add' : 'put'),\n      mergeMap((method) => {\n\n        /* Opening a transaction */\n        return this.transaction('readwrite').pipe(mergeMap((transaction) => {\n\n          let request: IDBRequest;\n\n          /* Adding or updating local storage, based on previous checking */\n          switch (method) {\n            case 'add':\n              request = transaction.add({ [this.dataPath]: data }, key);\n              break;\n            case 'put':\n            default:\n              request = transaction.put({ [this.dataPath]: data }, key);\n              break;\n          }\n\n          /* Merging success (passing true) and error events and autoclosing the observable */\n          return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `setter`)) as Observable<boolean>)\n            .pipe(first());\n\n        }));\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    /* Opening a transaction and checking if the item exists in local storage */\n    return this.getItem(key).pipe(\n      mergeMap((data) => {\n\n        /* If the item exists in local storage */\n        if (data != null) {\n\n          /* Opening a transaction */\n          return this.transaction('readwrite').pipe(mergeMap((transaction) => {\n\n            /* Deleting the item in local storage */\n            const request = transaction.delete(key);\n\n            /* Merging success (passing true) and error events and autoclosing the observable */\n            return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `remover`)) as Observable<boolean>)\n              .pipe(first());\n\n          }));\n\n        }\n\n        /* Passing true if the item does not exist in local storage */\n        return of(true);\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    /* Opening a transaction */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transaction) => {\n\n        /* Deleting all items from local storage */\n        const request = transaction.clear();\n\n        /* Merging success (passing true) and error events and autoclosing the observable */\n        return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `clearer`)) as Observable<boolean>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Connects to IndexedDB and creates the object store on first time\n   */\n  protected connect() {\n\n    /* Connecting to IndexedDB */\n    const request = indexedDB.open(this.dbName);\n\n    /* Listening the event fired on first connection, creating the object store for local storage */\n    (fromEvent(request, 'upgradeneeded') as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Getting the database connection */\n        const database = (event.target as IDBRequest).result as IDBDatabase;\n\n        /* Checking if the object store already exists, to avoid error */\n        if (!database.objectStoreNames.contains(this.objectStoreName)) {\n\n          /* Creating the object store for local storage */\n          database.createObjectStore(this.objectStoreName);\n\n        }\n\n      });\n\n    /* Listening the success event and converting to an RxJS Observable */\n    const success = fromEvent(request, 'success') as Observable<Event>;\n\n    /* Merging success and errors events */\n    (race(success, this.toErrorObservable(request, `connection`)) as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Storing the database connection for further access */\n        this.database.next((event.target as IDBRequest).result as IDBDatabase);\n\n      }, (error) => {\n\n        this.database.error(error as Error);\n\n      });\n\n  }\n\n  /**\n   * Opens an IndexedDB transaction and gets the local storage object store\n   * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n   * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable\n   */\n  protected transaction(mode: 'readonly' | 'readwrite' = 'readonly') {\n\n    /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */\n    return this.database\n      .pipe(map((database) => database.transaction([this.objectStoreName], mode).objectStore(this.objectStoreName)));\n\n  }\n\n  /**\n   * Transforms a IndexedDB success event in an RxJS Observable\n   * @param request The request to listen\n   * @returns A RxJS Observable with true value\n   */\n  protected toSuccessObservable(request: IDBRequest) {\n\n    /* Transforming a IndexedDB success event in an RxJS Observable with true value */\n    return (fromEvent(request, 'success') as Observable<Event>)\n      .pipe(map(() => true));\n\n  }\n\n  /**\n   * Transforms a IndexedDB error event in an RxJS ErrorObservable\n   * @param request The request to listen\n   * @param error Optionnal details about the error's origin\n   * @returns A RxJS ErrorObservable\n   */\n  protected toErrorObservable(request: IDBRequest, error = ``) {\n\n    /* Transforming a IndexedDB error event in an RxJS ErrorObservable */\n    return (fromEvent(request, 'error') as Observable<Event>)\n      .pipe(mergeMap((event) => throwError(new Error(`IndexedDB ${error} issue : ${request.error.message}.`))));\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, of, throwError } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageDatabase implements LocalDatabase {\n\n  /* Initializing native localStorage right now to be able to check its support on class instanciation */\n  protected localStorage = localStorage;\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string): Observable<T | null> {\n\n    const unparsedData = this.localStorage.getItem(key);\n    let parsedData: T | null = null;\n\n    if (unparsedData != null) {\n\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return throwError(new Error(`Invalid data in localStorage.`));\n      }\n\n    }\n\n    return of(parsedData);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    this.localStorage.setItem(key, JSON.stringify(data));\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    this.localStorage.removeItem(key);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    this.localStorage.clear();\n\n    return of(true);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MockLocalDatabase implements LocalDatabase {\n\n  protected localStorage = new Map<string, any>();\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n   getItem<T = any>(key: string) {\n\n    const rawData: T | null = this.localStorage.get(key);\n\n    return of((rawData !== undefined) ? rawData : null);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any) {\n\n    this.localStorage.set(key, data);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string) {\n\n    this.localStorage.delete(key);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear() {\n\n    this.localStorage.clear();\n\n    return of(true);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { JSONSchema, JSONSchemaType } from './json-schema';\n\n/**\n * @todo Add other JSON Schema validation features\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class JSONValidator {\n\n  /**\n   * Validate a JSON data against a JSON Schema\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema\n   * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n   */\n  validate(data: any, schema: JSONSchema): boolean {\n\n    if (!this.isObjectNotNull(schema)) {\n\n      throw new Error(`A schema must be an object (unlike spec, booleans are not supported to enforce strict types).`);\n\n    }\n\n    if (((!schema.hasOwnProperty('const') && !schema.hasOwnProperty('enum') && !schema.hasOwnProperty('type'))\n    || schema.type === 'array' || schema.type === 'object')\n    && !schema.hasOwnProperty('properties') && !schema.hasOwnProperty('items')) {\n\n      throw new Error(`Each value must have a 'type' or 'properties' or 'items' or 'const' or 'enum', to enforce strict types.`);\n\n    }\n\n    if (schema.hasOwnProperty('const') && (data !== schema.const)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('enum') && !this.validateEnum(data, schema)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('type') && !this.validateType(data, schema)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('items') && !this.validateItems(data, schema)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('properties')) {\n\n      if (schema.hasOwnProperty('required') && !this.validateRequired(data, schema)) {\n        return false;\n      }\n\n      if (!this.validateProperties(data, schema)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected isObjectNotNull(value: any): boolean {\n\n    return (value !== null) && (typeof value === 'object');\n\n  }\n\n  protected validateProperties(data: {}, schema: JSONSchema): boolean {\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    if (!schema.properties || !this.isObjectNotNull(schema.properties)) {\n\n      throw new Error(`'properties' must be a schema object.`);\n\n    }\n\n    /**\n     * Check if the object doesn't have more properties than expected\n     * Equivalent of additionalProperties: false\n     */\n    if (Object.keys(schema.properties).length !== Object.keys(data).length) {\n\n      return false;\n\n    }\n\n    /* Recursively validate all properties */\n    for (let property in schema.properties) {\n\n      if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n\n        if (!this.validate(data[property], schema.properties[property])) {\n\n          return false;\n\n        }\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateRequired(data: {}, schema: JSONSchema): boolean {\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    if (!Array.isArray(schema.required)) {\n\n      throw new Error(`'required' field must be an array. Note that since JSON Schema draft 6, booleans are not supported anymore.`);\n\n    }\n\n    for (let requiredProp of schema.required) {\n\n      if (typeof requiredProp !== 'string') {\n\n        throw new Error(`'required' array must contain strings only.`);\n\n      }\n\n      /* Checks if the property is present in the schema 'properties' */\n      if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {\n\n        throw new Error(`'required' properties must be described in 'properties' too.`);\n\n      }\n\n      /* Checks if the property is present in the data */\n      if (!data.hasOwnProperty(requiredProp)) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateEnum(data: any, schema: JSONSchema): boolean {\n\n    if (!Array.isArray(schema.enum)) {\n\n      throw new Error(`'enum' must be an array.`);\n\n    }\n\n    /** @todo Move to ES2016 .includes() ? */\n    return (schema.enum.indexOf(data) !== -1);\n\n  }\n\n  protected validateType(data: any, schema: JSONSchema): boolean {\n\n    if (Array.isArray(schema.type)) {\n\n      return this.validateTypeList(data, schema);\n\n    }\n\n    if (typeof schema.type !== 'string') {\n\n      throw new Error(`'type' must be a string (arrays of types are not supported yet).`);\n\n    }\n\n    if ((schema.type === 'null') && (data !== null)) {\n\n      return false;\n\n    }\n\n    if (schema.type === 'string') {\n\n      return this.validateString(data, schema);\n\n    }\n\n    if ((schema.type === 'number') || (schema.type === 'integer')) {\n\n      return this.validateNumber(data, schema);\n\n    }\n\n    if ((schema.type === 'boolean') && (typeof data !== 'boolean')) {\n\n      return false;\n\n    }\n\n    if ((schema.type === 'object') && (typeof data !== 'object')) {\n\n      return false;\n\n    }\n\n    return true;\n\n  }\n\n\n  protected validateTypeList(data: any, schema: JSONSchema): boolean {\n\n    const types = schema.type as JSONSchemaType[];\n\n    const typesTests: boolean[] = [];\n\n    for (let type of types) {\n\n      typesTests.push(this.validateType(data, { type }));\n\n    }\n\n    return (typesTests.indexOf(true) !== -1);\n\n  }\n\n  protected validateItems(data: any[], schema: JSONSchema): boolean {\n\n    if (!Array.isArray(data)) {\n\n      return false;\n\n    }\n\n    if (schema.hasOwnProperty('maxItems')) {\n\n      if ((typeof schema.maxItems !== 'number') || !Number.isInteger(schema.maxItems) || schema.maxItems < 0) {\n\n        throw new Error(`'maxItems' must be a non-negative integer.`);\n\n      }\n\n      if (data.length > schema.maxItems) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minItems')) {\n\n      if ((typeof schema.minItems !== 'number') || !Number.isInteger(schema.minItems) || schema.minItems < 0) {\n\n        throw new Error(`'minItems' must be a non-negative integer.`);\n\n      }\n\n      if (data.length < schema.minItems) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('uniqueItems')) {\n\n      if (typeof schema.uniqueItems !== 'boolean') {\n\n        throw new Error(`'minItems' must be a boolean.`);\n\n      }\n\n      if (schema.uniqueItems) {\n\n        const dataSet = new Set(data);\n\n        if (data.length !== dataSet.size) {\n          return false;\n        }\n\n      }\n\n    }\n\n    if (Array.isArray(schema.items)) {\n\n      return this.validateItemsList(data, schema);\n\n    }\n\n    if (!schema.items || !this.isObjectNotNull(schema.items)) {\n\n      throw new Error(`'items' must be a schema object.`);\n\n    }\n\n    for (let value of data) {\n\n      if (!this.validate(value, schema.items)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateItemsList(data: any, schema: JSONSchema): boolean {\n\n    const items = schema.items as JSONSchema[];\n\n    if (data.length !== items.length) {\n\n      return false;\n\n    }\n\n    for (let i = 0; i < items.length; i += 1) {\n\n      if (!this.validate(data[i], items[i])) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateString(data: any, schema: JSONSchema): boolean {\n\n    if (typeof data !== 'string') {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('maxLength')) {\n\n      if ((typeof schema.maxLength !== 'number') || !Number.isInteger(schema.maxLength) || schema.maxLength < 0) {\n\n        throw new Error(`'maxLength' must be a non-negative integer.`);\n\n      }\n\n      if (data.length > schema.maxLength) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minLength')) {\n\n      if ((typeof schema.minLength !== 'number') || !Number.isInteger(schema.minLength) || schema.minLength < 0) {\n\n        throw new Error(`'minLength' must be a non-negative integer.`);\n\n      }\n\n      if (data.length < schema.minLength) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('pattern')) {\n\n      if (typeof schema.pattern !== 'string') {\n\n        throw new Error(`'pattern' must be a string with a valid RegExp.`);\n\n      }\n\n      const regularExpression = new RegExp(schema.pattern);\n\n      if (!regularExpression.test(data)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateNumber(data: any, schema: JSONSchema): boolean {\n\n    if (typeof data !== 'number') {\n      return false;\n    }\n\n    if ((schema.type === 'integer') && !Number.isInteger(data)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('multipleOf')) {\n\n      if ((typeof schema.multipleOf !== 'number') || schema.multipleOf <= 0) {\n\n        throw new Error(`'multipleOf' must be a number strictly greater than 0.`);\n\n      }\n\n      if (!Number.isInteger(data / schema.multipleOf)) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('maximum')) {\n\n      if (typeof schema.maximum !== 'number') {\n\n        throw new Error(`'maximum' must be a number.`);\n\n      }\n\n      if (data > schema.maximum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('exclusiveMaximum')) {\n\n      if (typeof schema.exclusiveMaximum !== 'number') {\n\n        throw new Error(`'exclusiveMaximum' must be a number.`);\n\n      }\n\n      if (data >= schema.exclusiveMaximum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minimum')) {\n\n      if (typeof schema.minimum !== 'number') {\n\n        throw new Error(`'minimum' must be a number.`);\n\n      }\n\n      if (data < schema.minimum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('exclusiveMinimum')) {\n\n      if (typeof schema.exclusiveMinimum !== 'number') {\n\n        throw new Error(`'exclusiveMinimum' must be a number.`);\n\n      }\n\n      if (data <= schema.exclusiveMinimum) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError, of } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\nimport { LocalDatabase } from './databases/local-database';\nimport { JSONSchema } from './validation/json-schema';\nimport { JSONValidator } from './validation/json-validator';\n\nexport interface LSGetItemOptions {\n  schema?: JSONSchema | null;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorage {\n\n  protected readonly getItemOptionsDefault = {\n    schema: null\n  };\n\n  constructor(protected database: LocalDatabase, protected jsonValidator: JSONValidator) {}\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string, options: LSGetItemOptions = this.getItemOptionsDefault): Observable<T | null> {\n\n    return this.database.getItem<T>(key).pipe(\n\n      /* Validate data upon a json schema if requested */\n      mergeMap((data) => {\n\n        if (options.schema && data !== null) {\n\n          let validation = true;\n\n          try {\n            validation = this.jsonValidator.validate(data, options.schema);\n          } catch (error) {\n            return throwError(error);\n          }\n\n          if (!validation) {\n            return throwError(new Error(`JSON invalid`));\n          }\n\n        }\n\n        return of(data);\n\n      }));\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any): Observable<boolean> {\n\n    return this.database.setItem(key, data);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string): Observable<boolean> {\n\n    return this.database.removeItem(key);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear(): Observable<boolean> {\n\n    return this.database.clear();\n\n  }\n\n  /**\n   * Sets an item in local storage, and auto-subscribes\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   */\n  setItemSubscribe(key: string, data: any): void {\n\n    this.setItem(key, data).subscribe(() => {}, () => {});\n\n  }\n\n  /**\n   * Deletes an item in local storage, and auto-subscribes\n   * @param key The item's key\n   */\n   removeItemSubscribe(key: string): void {\n\n    this.removeItem(key).subscribe(() => {}, () => {});\n\n  }\n\n  /** Deletes all items from local storage, and auto-subscribes */\n  clearSubscribe(): void {\n\n    this.clear().subscribe(() => {}, () => {});\n\n  }\n\n}\n"],"names":["platformId","isPlatformBrowser","window","undefined","indexedDB","IndexedDBDatabase","localStorage","LocalStorageDatabase","MockLocalDatabase","this","database","ReplaySubject","connect","key","transaction","pipe","map","get","mergeMap","request","success","fromEvent","event","result","_this","dataPath","race","toErrorObservable","first","data","of","getItem","existingData","method","add","_a","put","_b","toSuccessObservable","delete","clear","open","dbName","subscribe","objectStoreNames","contains","objectStoreName","createObjectStore","next","error","mode","objectStore","throwError","Error","message","Injectable","providedIn","unparsedData","parsedData","JSON","parse","setItem","stringify","removeItem","Map","rawData","set","useFactory","localDatabaseFactory","deps","PLATFORM_ID","JSONValidator","schema","isObjectNotNull","hasOwnProperty","type","const","validateEnum","validateType","validateItems","validateRequired","validateProperties","value","properties","Object","keys","length","property","validate","Array","isArray","required","_i","requiredProp","enum","indexOf","validateTypeList","validateString","validateNumber","typesTests","types_1","push","maxItems","Number","isInteger","minItems","uniqueItems","dataSet","Set","size","items","validateItemsList","data_1","i","maxLength","minLength","pattern","RegExp","test","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","jsonValidator","LocalStorage","options","getItemOptionsDefault","validation","LocalDatabase"],"mappings":"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"}